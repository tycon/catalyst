(*  User declarations section for helper functions *)
open Spec
open RelLang
structure TypeSpec = RelSpec.TypeSpec
structure RefTy = RefinementType
val defaultCons = Con.default
val symbase = "sp_"
val count = ref 0
val genVar = fn _ => 
  let val id = symbase ^ (Int.toString (!count))
      val _ = count := !count + 1
  in
    Var.fromString id 
  end
fun $ (f,arg) = f arg
infixr 5 $
%%
(* ML Yacc Declarations *)
%name Spec (* tokens signature will be Spec_TOKENS *)
(* 
  The structure Token is defined by LrParser structure provided 
  by ml-yacc-lib  
*)
%header (functor SpecLrValsFun (structure Token : TOKEN
                                structure Spec : SPEC_LANG) : Spec_LRVALS)
%eop EOF
%noshift EOF
%pos int
(* 
  Lex functor is constructed to expect TOKENS signature 
  constructed from following declarations
 *)
%term   RELATION
      | TRUE
      | FALSE
      | ASSUME
      | NOT
      | PLUS
      | MINUS
      | UNION
      | CROSSPRD
      | SUBSETEQ
      | SUBSET
      | EQUALOP
      | IMP
      | HOLE
      | IFF
      | CONJ
      | DISJ
      | COLON
      | SEMICOLON
      | COMMA
      | STAR
      | LPAREN
      | RPAREN
      | LCURLY
      | RCURLY
      | LBRACE
      | RBRACE
      | ARROW
      | PIPE
      | ID of string
      | INT of int
      | EOF

%nonterm start of RelSpec.t
  | spec of RelSpec.t
  | decsandtys of RelSpec.t
  | reldec of StructuralRelation.t
  | patmatchseq of (Con.t * Var.t vector option * term) list
  | patmatch of Con.t * Var.t vector option * term
  | conpat of Con.t * Var.t vector option
  | conargs of Var.t vector
  | idseq of Var.t list
  | rterm of term
  | rexpr of expr
  | ratom of expr
  | elem of elem
  | elemseq of elem list
  | typespec of TypeSpec.t 
  | refty of RefinementType.t
  | reftyatom of RefinementType.t 
  | vartyatom of Var.t * RefinementType.t 
  | vartyseq of (Var.t * RefinementType.t) list
  | varty of Var.t * RefinementType.t 
  (*| reftyseq of RefinementType.t list
  | vartyatom of Var.t * RefinementType.t
  | vartyatomseq of (Var.t * RefTy.t) list
  | tyatom of RefinementType.t *)
  | basety of RefinementType.t
  | pred of Predicate.t
  | relpred of Predicate.RelPredicate.t
  | rpatom of Predicate.RelPredicate.t
  | bpatom of Predicate.BasePredicate.t
  | patom of Predicate.t
%verbose
%pure

%%
(* BNF Rules *)
start : spec (spec)

spec:   decsandtys (decsandtys)

decsandtys : reldec SEMICOLON decsandtys 
                (case decsandtys of RelSpec.T ({reldecs,typespecs}) => 
                    RelSpec.T {reldecs = Vector.fromList (reldec ::
                      (Vector.toList reldecs)), typespecs = typespecs})
           | typespec SEMICOLON decsandtys
                (case decsandtys of RelSpec.T {reldecs,typespecs} => 
                    RelSpec.T {reldecs = reldecs, typespecs = 
                    Vector.fromList (typespec :: (Vector.toList typespecs))})
           |  (RelSpec.T {reldecs = Vector.fromList [],
                  typespecs = Vector.fromList []})

reldec : RELATION ID patmatchseq 
          (StructuralRelation.T {id=RelId.fromString ID,
                map = Vector.fromList patmatchseq})
       | RELATION ID EQUALOP rterm
          (StructuralRelation.T{id=RelId.fromString ID,
                map = Vector.fromList [(defaultCons,NONE,rterm)]})

patmatchseq : patmatch PIPE patmatchseq (patmatch :: patmatchseq)
            | patmatch ([patmatch])

patmatch : LPAREN conpat RPAREN EQUALOP rterm 
              (case conpat of (c,vlop) => (c,vlop,rterm))
         | ID EQUALOP rterm ((Con.fromString ID,NONE,rterm))

conpat :  ID (Con.fromString ID, NONE)
       |  ID conargs (Con.fromString ID, SOME conargs)

conargs : ID (Vector.fromList [Var.fromString ID])
        | LPAREN idseq RPAREN (Vector.fromList idseq)

idseq : ID ([Var.fromString ID])
      | ID COMMA idseq ((Var.fromString ID)::idseq)

rterm : ID STAR (Star(RelId.fromString ID))
     | rexpr (Expr(rexpr))

rexpr : ratom CROSSPRD rexpr (X(ratom,rexpr))
      | ratom UNION rexpr (U(ratom,rexpr))
      | ratom MINUS rexpr (D(ratom,rexpr))
      | ratom (ratom)

ratom : LCURLY LPAREN RPAREN RCURLY (T(Vector.fromList []))
      | LCURLY LPAREN elemseq RPAREN RCURLY (T(Vector.fromList elemseq))
      | ID LPAREN ID RPAREN (R(RelId.fromString ID1, Var.fromString ID2))
      | LPAREN rexpr RPAREN (rexpr)

elemseq : elem ([elem])
        | elem COMMA elemseq (elem::elemseq)

elem : INT (Int(INT)) 
     | TRUE (Bool(true))
     | FALSE (Bool(false))
     | ID (Var(Var.fromString ID))

typespec : ASSUME ID COLON refty (TypeSpec.T (true,(Var.fromString ID),refty))
         | ID COLON refty (TypeSpec.T (false,(Var.fromString ID),refty))

(* From param-devel *)
refty : reftyatom (reftyatom)
      | vartyatom ARROW refty (RefTy.Arrow (vartyatom, refty))

reftyatom : basety (basety)
          | LPAREN vartyseq RPAREN  (case vartyseq of
                          [(v, refty as RefTy.Base _)] => 
                              RefTy.alphaRenameToVar refty v
                        | [(v,refty)] => refty
                        | _ => RefTy.Tuple (Vector.fromList vartyseq))

vartyatom : basety (case basety of 
                      RefTy.Base (v,_,_) => (v,RefTy.alphaRename basety)
                    | _ => Error.bug "Impossible case of basety")
          | LPAREN vartyseq RPAREN  (case vartyseq of
                          [x] => x 
                        | _ => (genVar (), RefTy.Tuple 
                            (Vector.fromList vartyseq)))

vartyseq : varty ([varty])
         | varty COMMA vartyseq (varty :: vartyseq)

varty : refty (let open RefTy in case refty of 
                          Base (v,_,_) => (v,alphaRename refty)
                        | Tuple _ => (genVar (),refty)
                        | Arrow _ => (genVar (),refty)
                        end)



(* Needs extension to specify ML type *)
basety : ID (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), 
                Predicate.truee()))
       | LCURLY ID RCURLY (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), 
                Predicate.truee()))
       | LCURLY ID PIPE pred RCURLY (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), pred))

(* Needs extension for base predicates *)
(* (v=true) => (not ('R1(x)= Rnull(x))) /\
   (v=false) => ('R2(x) = Rnull)*)
pred :  patom (patom)
     |  patom IMP pred (Predicate.If (patom,pred)) 
     |  patom IFF pred (Predicate.Iff (patom,pred)) 
     |  patom CONJ pred (Predicate.Conj (patom,pred))
     |  patom DISJ pred (Predicate.Disj (patom,pred))

patom : TRUE (Predicate.truee())
      | HOLE (Predicate.newHole() )
      | NOT patom (Predicate.Not patom)
      | LPAREN pred RPAREN (pred)
      | rpatom (Predicate.Rel rpatom)
      | bpatom (Predicate.Base bpatom)

bpatom : LBRACE ID EQUALOP ID RBRACE (Predicate.BasePredicate.varEq 
                      (Var.fromString ID1, Var.fromString ID2))
       | LBRACE ID EQUALOP TRUE RBRACE (Predicate.BasePredicate.varBoolEq 
                      (Var.fromString ID, true)) 
       | LBRACE ID EQUALOP FALSE RBRACE (Predicate.BasePredicate.varBoolEq 
                      (Var.fromString ID, false)) 
    
rpatom : rexpr EQUALOP rexpr (Predicate.RelPredicate.Eq(rexpr1,rexpr2))
       | rexpr SUBSET rexpr (Predicate.RelPredicate.Sub(rexpr1,rexpr2))
       | rexpr SUBSETEQ rexpr (Predicate.RelPredicate.SubEq(rexpr1,rexpr2))
